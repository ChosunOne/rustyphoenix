// This file is generated by rust-protobuf 2.0.4. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Network {
    // message oneof groups
    pub request: ::std::option::Option<Network_oneof_request>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Network_oneof_request {
    status(Status),
    statusReturn(StatusReturn),
    ping(Ping),
    pingReturn(PingReturn),
    putTx(PutTx),
    putTxReturn(PutTxReturn),
    getTxs(GetTxs),
    getTxsReturn(GetTxsReturn),
    putBlock(PutBlock),
    putBlockReturn(PutBlockReturn),
    getBlocksByHash(GetBlocksByHash),
    getBlocksByHashReturn(GetBlocksByHashReturn),
    getHeadersByHash(GetHeadersByHash),
    getHeadersByHashReturn(GetHeadersByHashReturn),
    getBlocksByRange(GetBlocksByRange),
    getBlocksByRangeReturn(GetBlocksByRangeReturn),
    getHeadersByRange(GetHeadersByRange),
    getHeadersByRangeReturn(GetHeadersByRangeReturn),
    getPeers(GetPeers),
    getPeersReturn(GetPeersReturn),
    getTip(GetTip),
    getTipReturn(GetTipReturn),
    putHeaders(PutHeaders),
    putHeadersReturn(PutHeadersReturn),
    getHash(GetHash),
    getHashReturn(GetHashReturn),
    getBlockTxs(GetBlockTxs),
    getBlockTxsReturn(GetBlockTxsReturn),
}

impl Network {
    pub fn new() -> Network {
        ::std::default::Default::default()
    }

    // .Status status = 1;

    pub fn clear_status(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::status(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.request = ::std::option::Option::Some(Network_oneof_request::status(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut Status {
        if let ::std::option::Option::Some(Network_oneof_request::status(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::status(Status::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::status(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status(&mut self) -> Status {
        if self.has_status() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::status(v)) => v,
                _ => panic!(),
            }
        } else {
            Status::new()
        }
    }

    pub fn get_status(&self) -> &Status {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::status(ref v)) => v,
            _ => Status::default_instance(),
        }
    }

    // .StatusReturn statusReturn = 2;

    pub fn clear_statusReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_statusReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::statusReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_statusReturn(&mut self, v: StatusReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::statusReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_statusReturn(&mut self) -> &mut StatusReturn {
        if let ::std::option::Option::Some(Network_oneof_request::statusReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::statusReturn(StatusReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::statusReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_statusReturn(&mut self) -> StatusReturn {
        if self.has_statusReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::statusReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            StatusReturn::new()
        }
    }

    pub fn get_statusReturn(&self) -> &StatusReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::statusReturn(ref v)) => v,
            _ => StatusReturn::default_instance(),
        }
    }

    // .Ping ping = 3;

    pub fn clear_ping(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: Ping) {
        self.request = ::std::option::Option::Some(Network_oneof_request::ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut Ping {
        if let ::std::option::Option::Some(Network_oneof_request::ping(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::ping(Ping::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> Ping {
        if self.has_ping() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::ping(v)) => v,
                _ => panic!(),
            }
        } else {
            Ping::new()
        }
    }

    pub fn get_ping(&self) -> &Ping {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::ping(ref v)) => v,
            _ => Ping::default_instance(),
        }
    }

    // .PingReturn pingReturn = 4;

    pub fn clear_pingReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_pingReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::pingReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pingReturn(&mut self, v: PingReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::pingReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pingReturn(&mut self) -> &mut PingReturn {
        if let ::std::option::Option::Some(Network_oneof_request::pingReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::pingReturn(PingReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::pingReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pingReturn(&mut self) -> PingReturn {
        if self.has_pingReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::pingReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            PingReturn::new()
        }
    }

    pub fn get_pingReturn(&self) -> &PingReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::pingReturn(ref v)) => v,
            _ => PingReturn::default_instance(),
        }
    }

    // .PutTx putTx = 5;

    pub fn clear_putTx(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_putTx(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putTx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_putTx(&mut self, v: PutTx) {
        self.request = ::std::option::Option::Some(Network_oneof_request::putTx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_putTx(&mut self) -> &mut PutTx {
        if let ::std::option::Option::Some(Network_oneof_request::putTx(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::putTx(PutTx::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putTx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_putTx(&mut self) -> PutTx {
        if self.has_putTx() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::putTx(v)) => v,
                _ => panic!(),
            }
        } else {
            PutTx::new()
        }
    }

    pub fn get_putTx(&self) -> &PutTx {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putTx(ref v)) => v,
            _ => PutTx::default_instance(),
        }
    }

    // .PutTxReturn putTxReturn = 6;

    pub fn clear_putTxReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_putTxReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putTxReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_putTxReturn(&mut self, v: PutTxReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::putTxReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_putTxReturn(&mut self) -> &mut PutTxReturn {
        if let ::std::option::Option::Some(Network_oneof_request::putTxReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::putTxReturn(PutTxReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putTxReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_putTxReturn(&mut self) -> PutTxReturn {
        if self.has_putTxReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::putTxReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            PutTxReturn::new()
        }
    }

    pub fn get_putTxReturn(&self) -> &PutTxReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putTxReturn(ref v)) => v,
            _ => PutTxReturn::default_instance(),
        }
    }

    // .GetTxs getTxs = 7;

    pub fn clear_getTxs(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getTxs(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTxs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getTxs(&mut self, v: GetTxs) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getTxs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getTxs(&mut self) -> &mut GetTxs {
        if let ::std::option::Option::Some(Network_oneof_request::getTxs(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getTxs(GetTxs::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTxs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getTxs(&mut self) -> GetTxs {
        if self.has_getTxs() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getTxs(v)) => v,
                _ => panic!(),
            }
        } else {
            GetTxs::new()
        }
    }

    pub fn get_getTxs(&self) -> &GetTxs {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTxs(ref v)) => v,
            _ => GetTxs::default_instance(),
        }
    }

    // .GetTxsReturn getTxsReturn = 8;

    pub fn clear_getTxsReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getTxsReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTxsReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getTxsReturn(&mut self, v: GetTxsReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getTxsReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getTxsReturn(&mut self) -> &mut GetTxsReturn {
        if let ::std::option::Option::Some(Network_oneof_request::getTxsReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getTxsReturn(GetTxsReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTxsReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getTxsReturn(&mut self) -> GetTxsReturn {
        if self.has_getTxsReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getTxsReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            GetTxsReturn::new()
        }
    }

    pub fn get_getTxsReturn(&self) -> &GetTxsReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTxsReturn(ref v)) => v,
            _ => GetTxsReturn::default_instance(),
        }
    }

    // .PutBlock putBlock = 9;

    pub fn clear_putBlock(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_putBlock(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putBlock(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_putBlock(&mut self, v: PutBlock) {
        self.request = ::std::option::Option::Some(Network_oneof_request::putBlock(v))
    }

    // Mutable pointer to the field.
    pub fn mut_putBlock(&mut self) -> &mut PutBlock {
        if let ::std::option::Option::Some(Network_oneof_request::putBlock(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::putBlock(PutBlock::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putBlock(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_putBlock(&mut self) -> PutBlock {
        if self.has_putBlock() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::putBlock(v)) => v,
                _ => panic!(),
            }
        } else {
            PutBlock::new()
        }
    }

    pub fn get_putBlock(&self) -> &PutBlock {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putBlock(ref v)) => v,
            _ => PutBlock::default_instance(),
        }
    }

    // .PutBlockReturn putBlockReturn = 10;

    pub fn clear_putBlockReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_putBlockReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putBlockReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_putBlockReturn(&mut self, v: PutBlockReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::putBlockReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_putBlockReturn(&mut self) -> &mut PutBlockReturn {
        if let ::std::option::Option::Some(Network_oneof_request::putBlockReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::putBlockReturn(PutBlockReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putBlockReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_putBlockReturn(&mut self) -> PutBlockReturn {
        if self.has_putBlockReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::putBlockReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            PutBlockReturn::new()
        }
    }

    pub fn get_putBlockReturn(&self) -> &PutBlockReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putBlockReturn(ref v)) => v,
            _ => PutBlockReturn::default_instance(),
        }
    }

    // .GetBlocksByHash getBlocksByHash = 11;

    pub fn clear_getBlocksByHash(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getBlocksByHash(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByHash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBlocksByHash(&mut self, v: GetBlocksByHash) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByHash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBlocksByHash(&mut self) -> &mut GetBlocksByHash {
        if let ::std::option::Option::Some(Network_oneof_request::getBlocksByHash(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByHash(GetBlocksByHash::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByHash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBlocksByHash(&mut self) -> GetBlocksByHash {
        if self.has_getBlocksByHash() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getBlocksByHash(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBlocksByHash::new()
        }
    }

    pub fn get_getBlocksByHash(&self) -> &GetBlocksByHash {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByHash(ref v)) => v,
            _ => GetBlocksByHash::default_instance(),
        }
    }

    // .GetBlocksByHashReturn getBlocksByHashReturn = 12;

    pub fn clear_getBlocksByHashReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getBlocksByHashReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByHashReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBlocksByHashReturn(&mut self, v: GetBlocksByHashReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByHashReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBlocksByHashReturn(&mut self) -> &mut GetBlocksByHashReturn {
        if let ::std::option::Option::Some(Network_oneof_request::getBlocksByHashReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByHashReturn(GetBlocksByHashReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByHashReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBlocksByHashReturn(&mut self) -> GetBlocksByHashReturn {
        if self.has_getBlocksByHashReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getBlocksByHashReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBlocksByHashReturn::new()
        }
    }

    pub fn get_getBlocksByHashReturn(&self) -> &GetBlocksByHashReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByHashReturn(ref v)) => v,
            _ => GetBlocksByHashReturn::default_instance(),
        }
    }

    // .GetHeadersByHash getHeadersByHash = 13;

    pub fn clear_getHeadersByHash(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getHeadersByHash(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByHash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getHeadersByHash(&mut self, v: GetHeadersByHash) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByHash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getHeadersByHash(&mut self) -> &mut GetHeadersByHash {
        if let ::std::option::Option::Some(Network_oneof_request::getHeadersByHash(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByHash(GetHeadersByHash::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByHash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getHeadersByHash(&mut self) -> GetHeadersByHash {
        if self.has_getHeadersByHash() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getHeadersByHash(v)) => v,
                _ => panic!(),
            }
        } else {
            GetHeadersByHash::new()
        }
    }

    pub fn get_getHeadersByHash(&self) -> &GetHeadersByHash {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByHash(ref v)) => v,
            _ => GetHeadersByHash::default_instance(),
        }
    }

    // .GetHeadersByHashReturn getHeadersByHashReturn = 14;

    pub fn clear_getHeadersByHashReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getHeadersByHashReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByHashReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getHeadersByHashReturn(&mut self, v: GetHeadersByHashReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByHashReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getHeadersByHashReturn(&mut self) -> &mut GetHeadersByHashReturn {
        if let ::std::option::Option::Some(Network_oneof_request::getHeadersByHashReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByHashReturn(GetHeadersByHashReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByHashReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getHeadersByHashReturn(&mut self) -> GetHeadersByHashReturn {
        if self.has_getHeadersByHashReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getHeadersByHashReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            GetHeadersByHashReturn::new()
        }
    }

    pub fn get_getHeadersByHashReturn(&self) -> &GetHeadersByHashReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByHashReturn(ref v)) => v,
            _ => GetHeadersByHashReturn::default_instance(),
        }
    }

    // .GetBlocksByRange getBlocksByRange = 15;

    pub fn clear_getBlocksByRange(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getBlocksByRange(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByRange(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBlocksByRange(&mut self, v: GetBlocksByRange) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByRange(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBlocksByRange(&mut self) -> &mut GetBlocksByRange {
        if let ::std::option::Option::Some(Network_oneof_request::getBlocksByRange(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByRange(GetBlocksByRange::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByRange(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBlocksByRange(&mut self) -> GetBlocksByRange {
        if self.has_getBlocksByRange() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getBlocksByRange(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBlocksByRange::new()
        }
    }

    pub fn get_getBlocksByRange(&self) -> &GetBlocksByRange {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByRange(ref v)) => v,
            _ => GetBlocksByRange::default_instance(),
        }
    }

    // .GetBlocksByRangeReturn getBlocksByRangeReturn = 16;

    pub fn clear_getBlocksByRangeReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getBlocksByRangeReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByRangeReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBlocksByRangeReturn(&mut self, v: GetBlocksByRangeReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByRangeReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBlocksByRangeReturn(&mut self) -> &mut GetBlocksByRangeReturn {
        if let ::std::option::Option::Some(Network_oneof_request::getBlocksByRangeReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByRangeReturn(GetBlocksByRangeReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByRangeReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBlocksByRangeReturn(&mut self) -> GetBlocksByRangeReturn {
        if self.has_getBlocksByRangeReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getBlocksByRangeReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBlocksByRangeReturn::new()
        }
    }

    pub fn get_getBlocksByRangeReturn(&self) -> &GetBlocksByRangeReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlocksByRangeReturn(ref v)) => v,
            _ => GetBlocksByRangeReturn::default_instance(),
        }
    }

    // .GetHeadersByRange getHeadersByRange = 17;

    pub fn clear_getHeadersByRange(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getHeadersByRange(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByRange(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getHeadersByRange(&mut self, v: GetHeadersByRange) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByRange(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getHeadersByRange(&mut self) -> &mut GetHeadersByRange {
        if let ::std::option::Option::Some(Network_oneof_request::getHeadersByRange(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByRange(GetHeadersByRange::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByRange(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getHeadersByRange(&mut self) -> GetHeadersByRange {
        if self.has_getHeadersByRange() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getHeadersByRange(v)) => v,
                _ => panic!(),
            }
        } else {
            GetHeadersByRange::new()
        }
    }

    pub fn get_getHeadersByRange(&self) -> &GetHeadersByRange {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByRange(ref v)) => v,
            _ => GetHeadersByRange::default_instance(),
        }
    }

    // .GetHeadersByRangeReturn getHeadersByRangeReturn = 18;

    pub fn clear_getHeadersByRangeReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getHeadersByRangeReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByRangeReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getHeadersByRangeReturn(&mut self, v: GetHeadersByRangeReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByRangeReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getHeadersByRangeReturn(&mut self) -> &mut GetHeadersByRangeReturn {
        if let ::std::option::Option::Some(Network_oneof_request::getHeadersByRangeReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByRangeReturn(GetHeadersByRangeReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByRangeReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getHeadersByRangeReturn(&mut self) -> GetHeadersByRangeReturn {
        if self.has_getHeadersByRangeReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getHeadersByRangeReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            GetHeadersByRangeReturn::new()
        }
    }

    pub fn get_getHeadersByRangeReturn(&self) -> &GetHeadersByRangeReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHeadersByRangeReturn(ref v)) => v,
            _ => GetHeadersByRangeReturn::default_instance(),
        }
    }

    // .GetPeers getPeers = 19;

    pub fn clear_getPeers(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getPeers(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getPeers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getPeers(&mut self, v: GetPeers) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getPeers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getPeers(&mut self) -> &mut GetPeers {
        if let ::std::option::Option::Some(Network_oneof_request::getPeers(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getPeers(GetPeers::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getPeers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getPeers(&mut self) -> GetPeers {
        if self.has_getPeers() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getPeers(v)) => v,
                _ => panic!(),
            }
        } else {
            GetPeers::new()
        }
    }

    pub fn get_getPeers(&self) -> &GetPeers {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getPeers(ref v)) => v,
            _ => GetPeers::default_instance(),
        }
    }

    // .GetPeersReturn getPeersReturn = 20;

    pub fn clear_getPeersReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getPeersReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getPeersReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getPeersReturn(&mut self, v: GetPeersReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getPeersReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getPeersReturn(&mut self) -> &mut GetPeersReturn {
        if let ::std::option::Option::Some(Network_oneof_request::getPeersReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getPeersReturn(GetPeersReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getPeersReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getPeersReturn(&mut self) -> GetPeersReturn {
        if self.has_getPeersReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getPeersReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            GetPeersReturn::new()
        }
    }

    pub fn get_getPeersReturn(&self) -> &GetPeersReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getPeersReturn(ref v)) => v,
            _ => GetPeersReturn::default_instance(),
        }
    }

    // .GetTip getTip = 21;

    pub fn clear_getTip(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getTip(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getTip(&mut self, v: GetTip) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getTip(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getTip(&mut self) -> &mut GetTip {
        if let ::std::option::Option::Some(Network_oneof_request::getTip(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getTip(GetTip::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTip(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getTip(&mut self) -> GetTip {
        if self.has_getTip() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getTip(v)) => v,
                _ => panic!(),
            }
        } else {
            GetTip::new()
        }
    }

    pub fn get_getTip(&self) -> &GetTip {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTip(ref v)) => v,
            _ => GetTip::default_instance(),
        }
    }

    // .GetTipReturn getTipReturn = 22;

    pub fn clear_getTipReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getTipReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTipReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getTipReturn(&mut self, v: GetTipReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getTipReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getTipReturn(&mut self) -> &mut GetTipReturn {
        if let ::std::option::Option::Some(Network_oneof_request::getTipReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getTipReturn(GetTipReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTipReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getTipReturn(&mut self) -> GetTipReturn {
        if self.has_getTipReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getTipReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            GetTipReturn::new()
        }
    }

    pub fn get_getTipReturn(&self) -> &GetTipReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getTipReturn(ref v)) => v,
            _ => GetTipReturn::default_instance(),
        }
    }

    // .PutHeaders putHeaders = 23;

    pub fn clear_putHeaders(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_putHeaders(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putHeaders(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_putHeaders(&mut self, v: PutHeaders) {
        self.request = ::std::option::Option::Some(Network_oneof_request::putHeaders(v))
    }

    // Mutable pointer to the field.
    pub fn mut_putHeaders(&mut self) -> &mut PutHeaders {
        if let ::std::option::Option::Some(Network_oneof_request::putHeaders(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::putHeaders(PutHeaders::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putHeaders(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_putHeaders(&mut self) -> PutHeaders {
        if self.has_putHeaders() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::putHeaders(v)) => v,
                _ => panic!(),
            }
        } else {
            PutHeaders::new()
        }
    }

    pub fn get_putHeaders(&self) -> &PutHeaders {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putHeaders(ref v)) => v,
            _ => PutHeaders::default_instance(),
        }
    }

    // .PutHeadersReturn putHeadersReturn = 24;

    pub fn clear_putHeadersReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_putHeadersReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putHeadersReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_putHeadersReturn(&mut self, v: PutHeadersReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::putHeadersReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_putHeadersReturn(&mut self) -> &mut PutHeadersReturn {
        if let ::std::option::Option::Some(Network_oneof_request::putHeadersReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::putHeadersReturn(PutHeadersReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putHeadersReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_putHeadersReturn(&mut self) -> PutHeadersReturn {
        if self.has_putHeadersReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::putHeadersReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            PutHeadersReturn::new()
        }
    }

    pub fn get_putHeadersReturn(&self) -> &PutHeadersReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::putHeadersReturn(ref v)) => v,
            _ => PutHeadersReturn::default_instance(),
        }
    }

    // .GetHash getHash = 25;

    pub fn clear_getHash(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getHash(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getHash(&mut self, v: GetHash) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getHash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getHash(&mut self) -> &mut GetHash {
        if let ::std::option::Option::Some(Network_oneof_request::getHash(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getHash(GetHash::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getHash(&mut self) -> GetHash {
        if self.has_getHash() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getHash(v)) => v,
                _ => panic!(),
            }
        } else {
            GetHash::new()
        }
    }

    pub fn get_getHash(&self) -> &GetHash {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHash(ref v)) => v,
            _ => GetHash::default_instance(),
        }
    }

    // .GetHashReturn getHashReturn = 26;

    pub fn clear_getHashReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getHashReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHashReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getHashReturn(&mut self, v: GetHashReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getHashReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getHashReturn(&mut self) -> &mut GetHashReturn {
        if let ::std::option::Option::Some(Network_oneof_request::getHashReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getHashReturn(GetHashReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHashReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getHashReturn(&mut self) -> GetHashReturn {
        if self.has_getHashReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getHashReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            GetHashReturn::new()
        }
    }

    pub fn get_getHashReturn(&self) -> &GetHashReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getHashReturn(ref v)) => v,
            _ => GetHashReturn::default_instance(),
        }
    }

    // .GetBlockTxs getBlockTxs = 27;

    pub fn clear_getBlockTxs(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getBlockTxs(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlockTxs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBlockTxs(&mut self, v: GetBlockTxs) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getBlockTxs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBlockTxs(&mut self) -> &mut GetBlockTxs {
        if let ::std::option::Option::Some(Network_oneof_request::getBlockTxs(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getBlockTxs(GetBlockTxs::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlockTxs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBlockTxs(&mut self) -> GetBlockTxs {
        if self.has_getBlockTxs() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getBlockTxs(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBlockTxs::new()
        }
    }

    pub fn get_getBlockTxs(&self) -> &GetBlockTxs {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlockTxs(ref v)) => v,
            _ => GetBlockTxs::default_instance(),
        }
    }

    // .GetBlockTxsReturn getBlockTxsReturn = 28;

    pub fn clear_getBlockTxsReturn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_getBlockTxsReturn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlockTxsReturn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBlockTxsReturn(&mut self, v: GetBlockTxsReturn) {
        self.request = ::std::option::Option::Some(Network_oneof_request::getBlockTxsReturn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBlockTxsReturn(&mut self) -> &mut GetBlockTxsReturn {
        if let ::std::option::Option::Some(Network_oneof_request::getBlockTxsReturn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(Network_oneof_request::getBlockTxsReturn(GetBlockTxsReturn::new()));
        }
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlockTxsReturn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBlockTxsReturn(&mut self) -> GetBlockTxsReturn {
        if self.has_getBlockTxsReturn() {
            match self.request.take() {
                ::std::option::Option::Some(Network_oneof_request::getBlockTxsReturn(v)) => v,
                _ => panic!(),
            }
        } else {
            GetBlockTxsReturn::new()
        }
    }

    pub fn get_getBlockTxsReturn(&self) -> &GetBlockTxsReturn {
        match self.request {
            ::std::option::Option::Some(Network_oneof_request::getBlockTxsReturn(ref v)) => v,
            _ => GetBlockTxsReturn::default_instance(),
        }
    }
}

impl ::protobuf::Message for Network {
    fn is_initialized(&self) -> bool {
        if let Some(Network_oneof_request::status(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::statusReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::ping(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::pingReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::putTx(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::putTxReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getTxs(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getTxsReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::putBlock(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::putBlockReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getBlocksByHash(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getBlocksByHashReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getHeadersByHash(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getHeadersByHashReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getBlocksByRange(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getBlocksByRangeReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getHeadersByRange(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getHeadersByRangeReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getPeers(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getPeersReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getTip(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getTipReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::putHeaders(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::putHeadersReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getHash(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getHashReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getBlockTxs(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Network_oneof_request::getBlockTxsReturn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::status(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::statusReturn(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::ping(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::pingReturn(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::putTx(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::putTxReturn(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getTxs(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getTxsReturn(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::putBlock(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::putBlockReturn(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByHash(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByHashReturn(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByHash(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByHashReturn(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByRange(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getBlocksByRangeReturn(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByRange(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getHeadersByRangeReturn(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getPeers(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getPeersReturn(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getTip(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getTipReturn(is.read_message()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::putHeaders(is.read_message()?));
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::putHeadersReturn(is.read_message()?));
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getHash(is.read_message()?));
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getHashReturn(is.read_message()?));
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getBlockTxs(is.read_message()?));
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(Network_oneof_request::getBlockTxsReturn(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &Network_oneof_request::status(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::statusReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::pingReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::putTx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::putTxReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getTxs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getTxsReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::putBlock(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::putBlockReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getBlocksByHash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getBlocksByHashReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getHeadersByHash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getHeadersByHashReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getBlocksByRange(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getBlocksByRangeReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getHeadersByRange(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getHeadersByRangeReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getPeers(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getPeersReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getTip(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getTipReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::putHeaders(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::putHeadersReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getHash(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getHashReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getBlockTxs(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Network_oneof_request::getBlockTxsReturn(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &Network_oneof_request::status(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::statusReturn(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::ping(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::pingReturn(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::putTx(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::putTxReturn(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getTxs(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getTxsReturn(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::putBlock(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::putBlockReturn(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getBlocksByHash(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getBlocksByHashReturn(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getHeadersByHash(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getHeadersByHashReturn(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getBlocksByRange(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getBlocksByRangeReturn(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getHeadersByRange(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getHeadersByRangeReturn(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getPeers(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getPeersReturn(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getTip(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getTipReturn(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::putHeaders(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::putHeadersReturn(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getHash(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getHashReturn(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getBlockTxs(ref v) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Network_oneof_request::getBlockTxsReturn(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Network {
        Network::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Status>(
                    "status",
                    Network::has_status,
                    Network::get_status,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StatusReturn>(
                    "statusReturn",
                    Network::has_statusReturn,
                    Network::get_statusReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Ping>(
                    "ping",
                    Network::has_ping,
                    Network::get_ping,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PingReturn>(
                    "pingReturn",
                    Network::has_pingReturn,
                    Network::get_pingReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PutTx>(
                    "putTx",
                    Network::has_putTx,
                    Network::get_putTx,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PutTxReturn>(
                    "putTxReturn",
                    Network::has_putTxReturn,
                    Network::get_putTxReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetTxs>(
                    "getTxs",
                    Network::has_getTxs,
                    Network::get_getTxs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetTxsReturn>(
                    "getTxsReturn",
                    Network::has_getTxsReturn,
                    Network::get_getTxsReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PutBlock>(
                    "putBlock",
                    Network::has_putBlock,
                    Network::get_putBlock,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PutBlockReturn>(
                    "putBlockReturn",
                    Network::has_putBlockReturn,
                    Network::get_putBlockReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetBlocksByHash>(
                    "getBlocksByHash",
                    Network::has_getBlocksByHash,
                    Network::get_getBlocksByHash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetBlocksByHashReturn>(
                    "getBlocksByHashReturn",
                    Network::has_getBlocksByHashReturn,
                    Network::get_getBlocksByHashReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetHeadersByHash>(
                    "getHeadersByHash",
                    Network::has_getHeadersByHash,
                    Network::get_getHeadersByHash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetHeadersByHashReturn>(
                    "getHeadersByHashReturn",
                    Network::has_getHeadersByHashReturn,
                    Network::get_getHeadersByHashReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetBlocksByRange>(
                    "getBlocksByRange",
                    Network::has_getBlocksByRange,
                    Network::get_getBlocksByRange,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetBlocksByRangeReturn>(
                    "getBlocksByRangeReturn",
                    Network::has_getBlocksByRangeReturn,
                    Network::get_getBlocksByRangeReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetHeadersByRange>(
                    "getHeadersByRange",
                    Network::has_getHeadersByRange,
                    Network::get_getHeadersByRange,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetHeadersByRangeReturn>(
                    "getHeadersByRangeReturn",
                    Network::has_getHeadersByRangeReturn,
                    Network::get_getHeadersByRangeReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetPeers>(
                    "getPeers",
                    Network::has_getPeers,
                    Network::get_getPeers,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetPeersReturn>(
                    "getPeersReturn",
                    Network::has_getPeersReturn,
                    Network::get_getPeersReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetTip>(
                    "getTip",
                    Network::has_getTip,
                    Network::get_getTip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetTipReturn>(
                    "getTipReturn",
                    Network::has_getTipReturn,
                    Network::get_getTipReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PutHeaders>(
                    "putHeaders",
                    Network::has_putHeaders,
                    Network::get_putHeaders,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PutHeadersReturn>(
                    "putHeadersReturn",
                    Network::has_putHeadersReturn,
                    Network::get_putHeadersReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetHash>(
                    "getHash",
                    Network::has_getHash,
                    Network::get_getHash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetHashReturn>(
                    "getHashReturn",
                    Network::has_getHashReturn,
                    Network::get_getHashReturn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetBlockTxs>(
                    "getBlockTxs",
                    Network::has_getBlockTxs,
                    Network::get_getBlockTxs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetBlockTxsReturn>(
                    "getBlockTxsReturn",
                    Network::has_getBlockTxsReturn,
                    Network::get_getBlockTxsReturn,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Network>(
                    "Network",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Network {
        static mut instance: ::protobuf::lazy::Lazy<Network> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Network,
        };
        unsafe {
            instance.get(Network::new)
        }
    }
}

impl ::protobuf::Clear for Network {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_statusReturn();
        self.clear_ping();
        self.clear_pingReturn();
        self.clear_putTx();
        self.clear_putTxReturn();
        self.clear_getTxs();
        self.clear_getTxsReturn();
        self.clear_putBlock();
        self.clear_putBlockReturn();
        self.clear_getBlocksByHash();
        self.clear_getBlocksByHashReturn();
        self.clear_getHeadersByHash();
        self.clear_getHeadersByHashReturn();
        self.clear_getBlocksByRange();
        self.clear_getBlocksByRangeReturn();
        self.clear_getHeadersByRange();
        self.clear_getHeadersByRangeReturn();
        self.clear_getPeers();
        self.clear_getPeersReturn();
        self.clear_getTip();
        self.clear_getTipReturn();
        self.clear_putHeaders();
        self.clear_putHeadersReturn();
        self.clear_getHash();
        self.clear_getHashReturn();
        self.clear_getBlockTxs();
        self.clear_getBlockTxsReturn();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Network {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Network {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Status {
    // message fields
    pub version: u32,
    pub networkid: ::std::string::String,
    pub port: i32,
    pub guid: ::std::string::String,
    pub publicPort: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // uint32 version = 1;

    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = v;
    }

    pub fn get_version(&self) -> u32 {
        self.version
    }

    // string networkid = 2;

    pub fn clear_networkid(&mut self) {
        self.networkid.clear();
    }

    // Param is passed by value, moved
    pub fn set_networkid(&mut self, v: ::std::string::String) {
        self.networkid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_networkid(&mut self) -> &mut ::std::string::String {
        &mut self.networkid
    }

    // Take field
    pub fn take_networkid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.networkid, ::std::string::String::new())
    }

    pub fn get_networkid(&self) -> &str {
        &self.networkid
    }

    // int32 port = 5;

    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }

    pub fn get_port(&self) -> i32 {
        self.port
    }

    // string guid = 6;

    pub fn clear_guid(&mut self) {
        self.guid.clear();
    }

    // Param is passed by value, moved
    pub fn set_guid(&mut self, v: ::std::string::String) {
        self.guid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid(&mut self) -> &mut ::std::string::String {
        &mut self.guid
    }

    // Take field
    pub fn take_guid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.guid, ::std::string::String::new())
    }

    pub fn get_guid(&self) -> &str {
        &self.guid
    }

    // int32 publicPort = 7;

    pub fn clear_publicPort(&mut self) {
        self.publicPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_publicPort(&mut self, v: i32) {
        self.publicPort = v;
    }

    pub fn get_publicPort(&self) -> i32 {
        self.publicPort
    }
}

impl ::protobuf::Message for Status {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.networkid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.guid)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.publicPort = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.networkid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.networkid);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(5, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.guid.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.guid);
        }
        if self.publicPort != 0 {
            my_size += ::protobuf::rt::value_size(7, self.publicPort, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.version != 0 {
            os.write_uint32(1, self.version)?;
        }
        if !self.networkid.is_empty() {
            os.write_string(2, &self.networkid)?;
        }
        if self.port != 0 {
            os.write_int32(5, self.port)?;
        }
        if !self.guid.is_empty() {
            os.write_string(6, &self.guid)?;
        }
        if self.publicPort != 0 {
            os.write_int32(7, self.publicPort)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status {
        Status::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &Status| { &m.version },
                    |m: &mut Status| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "networkid",
                    |m: &Status| { &m.networkid },
                    |m: &mut Status| { &mut m.networkid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    |m: &Status| { &m.port },
                    |m: &mut Status| { &mut m.port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "guid",
                    |m: &Status| { &m.guid },
                    |m: &mut Status| { &mut m.guid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "publicPort",
                    |m: &Status| { &m.publicPort },
                    |m: &mut Status| { &mut m.publicPort },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Status>(
                    "Status",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Status {
        static mut instance: ::protobuf::lazy::Lazy<Status> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Status,
        };
        unsafe {
            instance.get(Status::new)
        }
    }
}

impl ::protobuf::Clear for Status {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_networkid();
        self.clear_port();
        self.clear_guid();
        self.clear_publicPort();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusReturn {
    // message fields
    pub success: bool,
    pub status: ::protobuf::SingularPtrField<Status>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StatusReturn {
    pub fn new() -> StatusReturn {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }

    // .Status status = 2;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> Status {
        self.status.take().unwrap_or_else(|| Status::new())
    }

    pub fn get_status(&self) -> &Status {
        self.status.as_ref().unwrap_or_else(|| Status::default_instance())
    }
}

impl ::protobuf::Message for StatusReturn {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusReturn {
        StatusReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &StatusReturn| { &m.success },
                    |m: &mut StatusReturn| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Status>>(
                    "status",
                    |m: &StatusReturn| { &m.status },
                    |m: &mut StatusReturn| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatusReturn>(
                    "StatusReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusReturn {
        static mut instance: ::protobuf::lazy::Lazy<StatusReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusReturn,
        };
        unsafe {
            instance.get(StatusReturn::new)
        }
    }
}

impl ::protobuf::Clear for StatusReturn {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ping {
    // message fields
    pub nonce: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // uint64 nonce = 1;

    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = v;
    }

    pub fn get_nonce(&self) -> u64 {
        self.nonce
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_uint64(1, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nonce",
                    |m: &Ping| { &m.nonce },
                    |m: &mut Ping| { &mut m.nonce },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ping>(
                    "Ping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Ping {
        static mut instance: ::protobuf::lazy::Lazy<Ping> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ping,
        };
        unsafe {
            instance.get(Ping::new)
        }
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.clear_nonce();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PingReturn {
    // message fields
    pub nonce: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PingReturn {
    pub fn new() -> PingReturn {
        ::std::default::Default::default()
    }

    // uint64 nonce = 1;

    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = v;
    }

    pub fn get_nonce(&self) -> u64 {
        self.nonce
    }
}

impl ::protobuf::Message for PingReturn {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_uint64(1, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PingReturn {
        PingReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nonce",
                    |m: &PingReturn| { &m.nonce },
                    |m: &mut PingReturn| { &mut m.nonce },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PingReturn>(
                    "PingReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PingReturn {
        static mut instance: ::protobuf::lazy::Lazy<PingReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PingReturn,
        };
        unsafe {
            instance.get(PingReturn::new)
        }
    }
}

impl ::protobuf::Clear for PingReturn {
    fn clear(&mut self) {
        self.clear_nonce();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PingReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutTx {
    // message fields
    pub txs: ::protobuf::RepeatedField<super::tx::Tx>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PutTx {
    pub fn new() -> PutTx {
        ::std::default::Default::default()
    }

    // repeated .Tx txs = 1;

    pub fn clear_txs(&mut self) {
        self.txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_txs(&mut self, v: ::protobuf::RepeatedField<super::tx::Tx>) {
        self.txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txs(&mut self) -> &mut ::protobuf::RepeatedField<super::tx::Tx> {
        &mut self.txs
    }

    // Take field
    pub fn take_txs(&mut self) -> ::protobuf::RepeatedField<super::tx::Tx> {
        ::std::mem::replace(&mut self.txs, ::protobuf::RepeatedField::new())
    }

    pub fn get_txs(&self) -> &[super::tx::Tx] {
        &self.txs
    }
}

impl ::protobuf::Message for PutTx {
    fn is_initialized(&self) -> bool {
        for v in &self.txs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.txs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.txs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutTx {
        PutTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tx::Tx>>(
                    "txs",
                    |m: &PutTx| { &m.txs },
                    |m: &mut PutTx| { &mut m.txs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PutTx>(
                    "PutTx",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PutTx {
        static mut instance: ::protobuf::lazy::Lazy<PutTx> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PutTx,
        };
        unsafe {
            instance.get(PutTx::new)
        }
    }
}

impl ::protobuf::Clear for PutTx {
    fn clear(&mut self) {
        self.clear_txs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutTx {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutTxReturn {
    // message fields
    pub success: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PutTxReturn {
    pub fn new() -> PutTxReturn {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }
}

impl ::protobuf::Message for PutTxReturn {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutTxReturn {
        PutTxReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &PutTxReturn| { &m.success },
                    |m: &mut PutTxReturn| { &mut m.success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PutTxReturn>(
                    "PutTxReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PutTxReturn {
        static mut instance: ::protobuf::lazy::Lazy<PutTxReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PutTxReturn,
        };
        unsafe {
            instance.get(PutTxReturn::new)
        }
    }
}

impl ::protobuf::Clear for PutTxReturn {
    fn clear(&mut self) {
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutTxReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutTxReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockTxs {
    // message fields
    pub hashes: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlockTxs {
    pub fn new() -> GetBlockTxs {
        ::std::default::Default::default()
    }

    // repeated bytes hashes = 1;

    pub fn clear_hashes(&mut self) {
        self.hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashes(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.hashes
    }

    // Take field
    pub fn take_hashes(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.hashes, ::protobuf::RepeatedField::new())
    }

    pub fn get_hashes(&self) -> &[::std::vec::Vec<u8>] {
        &self.hashes
    }
}

impl ::protobuf::Message for GetBlockTxs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hashes {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hashes {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockTxs {
        GetBlockTxs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hashes",
                    |m: &GetBlockTxs| { &m.hashes },
                    |m: &mut GetBlockTxs| { &mut m.hashes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockTxs>(
                    "GetBlockTxs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlockTxs {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockTxs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockTxs,
        };
        unsafe {
            instance.get(GetBlockTxs::new)
        }
    }
}

impl ::protobuf::Clear for GetBlockTxs {
    fn clear(&mut self) {
        self.clear_hashes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockTxs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockTxs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockTxs {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub txs: ::protobuf::RepeatedField<super::tx::Tx>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BlockTxs {
    pub fn new() -> BlockTxs {
        ::std::default::Default::default()
    }

    // bytes hash = 1;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }

    // repeated .Tx txs = 2;

    pub fn clear_txs(&mut self) {
        self.txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_txs(&mut self, v: ::protobuf::RepeatedField<super::tx::Tx>) {
        self.txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txs(&mut self) -> &mut ::protobuf::RepeatedField<super::tx::Tx> {
        &mut self.txs
    }

    // Take field
    pub fn take_txs(&mut self) -> ::protobuf::RepeatedField<super::tx::Tx> {
        ::std::mem::replace(&mut self.txs, ::protobuf::RepeatedField::new())
    }

    pub fn get_txs(&self) -> &[super::tx::Tx] {
        &self.txs
    }
}

impl ::protobuf::Message for BlockTxs {
    fn is_initialized(&self) -> bool {
        for v in &self.txs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        for value in &self.txs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        for v in &self.txs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockTxs {
        BlockTxs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &BlockTxs| { &m.hash },
                    |m: &mut BlockTxs| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tx::Tx>>(
                    "txs",
                    |m: &BlockTxs| { &m.txs },
                    |m: &mut BlockTxs| { &mut m.txs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockTxs>(
                    "BlockTxs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockTxs {
        static mut instance: ::protobuf::lazy::Lazy<BlockTxs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockTxs,
        };
        unsafe {
            instance.get(BlockTxs::new)
        }
    }
}

impl ::protobuf::Clear for BlockTxs {
    fn clear(&mut self) {
        self.clear_hash();
        self.clear_txs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockTxs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockTxs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockTxsReturn {
    // message fields
    pub txBlocks: ::protobuf::RepeatedField<BlockTxs>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlockTxsReturn {
    pub fn new() -> GetBlockTxsReturn {
        ::std::default::Default::default()
    }

    // repeated .BlockTxs txBlocks = 1;

    pub fn clear_txBlocks(&mut self) {
        self.txBlocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_txBlocks(&mut self, v: ::protobuf::RepeatedField<BlockTxs>) {
        self.txBlocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txBlocks(&mut self) -> &mut ::protobuf::RepeatedField<BlockTxs> {
        &mut self.txBlocks
    }

    // Take field
    pub fn take_txBlocks(&mut self) -> ::protobuf::RepeatedField<BlockTxs> {
        ::std::mem::replace(&mut self.txBlocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_txBlocks(&self) -> &[BlockTxs] {
        &self.txBlocks
    }
}

impl ::protobuf::Message for GetBlockTxsReturn {
    fn is_initialized(&self) -> bool {
        for v in &self.txBlocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txBlocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.txBlocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.txBlocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockTxsReturn {
        GetBlockTxsReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockTxs>>(
                    "txBlocks",
                    |m: &GetBlockTxsReturn| { &m.txBlocks },
                    |m: &mut GetBlockTxsReturn| { &mut m.txBlocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockTxsReturn>(
                    "GetBlockTxsReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlockTxsReturn {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockTxsReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockTxsReturn,
        };
        unsafe {
            instance.get(GetBlockTxsReturn::new)
        }
    }
}

impl ::protobuf::Clear for GetBlockTxsReturn {
    fn clear(&mut self) {
        self.clear_txBlocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockTxsReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockTxsReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTxs {
    // message fields
    pub minFee: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetTxs {
    pub fn new() -> GetTxs {
        ::std::default::Default::default()
    }

    // uint64 minFee = 1;

    pub fn clear_minFee(&mut self) {
        self.minFee = 0;
    }

    // Param is passed by value, moved
    pub fn set_minFee(&mut self, v: u64) {
        self.minFee = v;
    }

    pub fn get_minFee(&self) -> u64 {
        self.minFee
    }
}

impl ::protobuf::Message for GetTxs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minFee = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.minFee != 0 {
            my_size += ::protobuf::rt::value_size(1, self.minFee, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.minFee != 0 {
            os.write_uint64(1, self.minFee)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTxs {
        GetTxs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "minFee",
                    |m: &GetTxs| { &m.minFee },
                    |m: &mut GetTxs| { &mut m.minFee },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTxs>(
                    "GetTxs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTxs {
        static mut instance: ::protobuf::lazy::Lazy<GetTxs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTxs,
        };
        unsafe {
            instance.get(GetTxs::new)
        }
    }
}

impl ::protobuf::Clear for GetTxs {
    fn clear(&mut self) {
        self.clear_minFee();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTxs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTxsReturn {
    // message fields
    pub success: bool,
    pub txs: ::protobuf::RepeatedField<super::tx::Tx>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetTxsReturn {
    pub fn new() -> GetTxsReturn {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }

    // repeated .Tx txs = 2;

    pub fn clear_txs(&mut self) {
        self.txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_txs(&mut self, v: ::protobuf::RepeatedField<super::tx::Tx>) {
        self.txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txs(&mut self) -> &mut ::protobuf::RepeatedField<super::tx::Tx> {
        &mut self.txs
    }

    // Take field
    pub fn take_txs(&mut self) -> ::protobuf::RepeatedField<super::tx::Tx> {
        ::std::mem::replace(&mut self.txs, ::protobuf::RepeatedField::new())
    }

    pub fn get_txs(&self) -> &[super::tx::Tx] {
        &self.txs
    }
}

impl ::protobuf::Message for GetTxsReturn {
    fn is_initialized(&self) -> bool {
        for v in &self.txs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        for value in &self.txs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        for v in &self.txs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTxsReturn {
        GetTxsReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &GetTxsReturn| { &m.success },
                    |m: &mut GetTxsReturn| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tx::Tx>>(
                    "txs",
                    |m: &GetTxsReturn| { &m.txs },
                    |m: &mut GetTxsReturn| { &mut m.txs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTxsReturn>(
                    "GetTxsReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTxsReturn {
        static mut instance: ::protobuf::lazy::Lazy<GetTxsReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTxsReturn,
        };
        unsafe {
            instance.get(GetTxsReturn::new)
        }
    }
}

impl ::protobuf::Clear for GetTxsReturn {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_txs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTxsReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxsReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutBlock {
    // message fields
    pub blocks: ::protobuf::RepeatedField<super::block::Block>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PutBlock {
    pub fn new() -> PutBlock {
        ::std::default::Default::default()
    }

    // repeated .Block blocks = 1;

    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::block::Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::block::Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::block::Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blocks(&self) -> &[super::block::Block] {
        &self.blocks
    }
}

impl ::protobuf::Message for PutBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutBlock {
        PutBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::block::Block>>(
                    "blocks",
                    |m: &PutBlock| { &m.blocks },
                    |m: &mut PutBlock| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PutBlock>(
                    "PutBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PutBlock {
        static mut instance: ::protobuf::lazy::Lazy<PutBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PutBlock,
        };
        unsafe {
            instance.get(PutBlock::new)
        }
    }
}

impl ::protobuf::Clear for PutBlock {
    fn clear(&mut self) {
        self.clear_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutBlockReturn {
    // message fields
    pub statusChanges: ::protobuf::RepeatedField<StatusChange>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PutBlockReturn {
    pub fn new() -> PutBlockReturn {
        ::std::default::Default::default()
    }

    // repeated .StatusChange statusChanges = 1;

    pub fn clear_statusChanges(&mut self) {
        self.statusChanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_statusChanges(&mut self, v: ::protobuf::RepeatedField<StatusChange>) {
        self.statusChanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statusChanges(&mut self) -> &mut ::protobuf::RepeatedField<StatusChange> {
        &mut self.statusChanges
    }

    // Take field
    pub fn take_statusChanges(&mut self) -> ::protobuf::RepeatedField<StatusChange> {
        ::std::mem::replace(&mut self.statusChanges, ::protobuf::RepeatedField::new())
    }

    pub fn get_statusChanges(&self) -> &[StatusChange] {
        &self.statusChanges
    }
}

impl ::protobuf::Message for PutBlockReturn {
    fn is_initialized(&self) -> bool {
        for v in &self.statusChanges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statusChanges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.statusChanges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.statusChanges {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutBlockReturn {
        PutBlockReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusChange>>(
                    "statusChanges",
                    |m: &PutBlockReturn| { &m.statusChanges },
                    |m: &mut PutBlockReturn| { &mut m.statusChanges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PutBlockReturn>(
                    "PutBlockReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PutBlockReturn {
        static mut instance: ::protobuf::lazy::Lazy<PutBlockReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PutBlockReturn,
        };
        unsafe {
            instance.get(PutBlockReturn::new)
        }
    }
}

impl ::protobuf::Clear for PutBlockReturn {
    fn clear(&mut self) {
        self.clear_statusChanges();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutBlockReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutBlockReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NewTx {
    // message fields
    pub txs: ::protobuf::RepeatedField<super::tx::Tx>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NewTx {
    pub fn new() -> NewTx {
        ::std::default::Default::default()
    }

    // repeated .Tx txs = 1;

    pub fn clear_txs(&mut self) {
        self.txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_txs(&mut self, v: ::protobuf::RepeatedField<super::tx::Tx>) {
        self.txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txs(&mut self) -> &mut ::protobuf::RepeatedField<super::tx::Tx> {
        &mut self.txs
    }

    // Take field
    pub fn take_txs(&mut self) -> ::protobuf::RepeatedField<super::tx::Tx> {
        ::std::mem::replace(&mut self.txs, ::protobuf::RepeatedField::new())
    }

    pub fn get_txs(&self) -> &[super::tx::Tx] {
        &self.txs
    }
}

impl ::protobuf::Message for NewTx {
    fn is_initialized(&self) -> bool {
        for v in &self.txs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.txs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.txs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewTx {
        NewTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tx::Tx>>(
                    "txs",
                    |m: &NewTx| { &m.txs },
                    |m: &mut NewTx| { &mut m.txs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NewTx>(
                    "NewTx",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NewTx {
        static mut instance: ::protobuf::lazy::Lazy<NewTx> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NewTx,
        };
        unsafe {
            instance.get(NewTx::new)
        }
    }
}

impl ::protobuf::Clear for NewTx {
    fn clear(&mut self) {
        self.clear_txs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewTx {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NewBlock {
    // message fields
    pub blocks: ::protobuf::RepeatedField<super::block::Block>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NewBlock {
    pub fn new() -> NewBlock {
        ::std::default::Default::default()
    }

    // repeated .Block blocks = 1;

    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::block::Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::block::Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::block::Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blocks(&self) -> &[super::block::Block] {
        &self.blocks
    }
}

impl ::protobuf::Message for NewBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewBlock {
        NewBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::block::Block>>(
                    "blocks",
                    |m: &NewBlock| { &m.blocks },
                    |m: &mut NewBlock| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NewBlock>(
                    "NewBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NewBlock {
        static mut instance: ::protobuf::lazy::Lazy<NewBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NewBlock,
        };
        unsafe {
            instance.get(NewBlock::new)
        }
    }
}

impl ::protobuf::Clear for NewBlock {
    fn clear(&mut self) {
        self.clear_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlocksByHash {
    // message fields
    pub hashes: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlocksByHash {
    pub fn new() -> GetBlocksByHash {
        ::std::default::Default::default()
    }

    // repeated bytes hashes = 1;

    pub fn clear_hashes(&mut self) {
        self.hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashes(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.hashes
    }

    // Take field
    pub fn take_hashes(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.hashes, ::protobuf::RepeatedField::new())
    }

    pub fn get_hashes(&self) -> &[::std::vec::Vec<u8>] {
        &self.hashes
    }
}

impl ::protobuf::Message for GetBlocksByHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hashes {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hashes {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksByHash {
        GetBlocksByHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hashes",
                    |m: &GetBlocksByHash| { &m.hashes },
                    |m: &mut GetBlocksByHash| { &mut m.hashes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlocksByHash>(
                    "GetBlocksByHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlocksByHash {
        static mut instance: ::protobuf::lazy::Lazy<GetBlocksByHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlocksByHash,
        };
        unsafe {
            instance.get(GetBlocksByHash::new)
        }
    }
}

impl ::protobuf::Clear for GetBlocksByHash {
    fn clear(&mut self) {
        self.clear_hashes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlocksByHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksByHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlocksByHashReturn {
    // message fields
    pub success: bool,
    pub blocks: ::protobuf::RepeatedField<super::block::Block>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlocksByHashReturn {
    pub fn new() -> GetBlocksByHashReturn {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }

    // repeated .Block blocks = 2;

    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::block::Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::block::Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::block::Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blocks(&self) -> &[super::block::Block] {
        &self.blocks
    }
}

impl ::protobuf::Message for GetBlocksByHashReturn {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksByHashReturn {
        GetBlocksByHashReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &GetBlocksByHashReturn| { &m.success },
                    |m: &mut GetBlocksByHashReturn| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::block::Block>>(
                    "blocks",
                    |m: &GetBlocksByHashReturn| { &m.blocks },
                    |m: &mut GetBlocksByHashReturn| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlocksByHashReturn>(
                    "GetBlocksByHashReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlocksByHashReturn {
        static mut instance: ::protobuf::lazy::Lazy<GetBlocksByHashReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlocksByHashReturn,
        };
        unsafe {
            instance.get(GetBlocksByHashReturn::new)
        }
    }
}

impl ::protobuf::Clear for GetBlocksByHashReturn {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlocksByHashReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksByHashReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetHeadersByHash {
    // message fields
    pub hashes: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetHeadersByHash {
    pub fn new() -> GetHeadersByHash {
        ::std::default::Default::default()
    }

    // repeated bytes hashes = 1;

    pub fn clear_hashes(&mut self) {
        self.hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashes(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.hashes
    }

    // Take field
    pub fn take_hashes(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.hashes, ::protobuf::RepeatedField::new())
    }

    pub fn get_hashes(&self) -> &[::std::vec::Vec<u8>] {
        &self.hashes
    }
}

impl ::protobuf::Message for GetHeadersByHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hashes {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hashes {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHeadersByHash {
        GetHeadersByHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hashes",
                    |m: &GetHeadersByHash| { &m.hashes },
                    |m: &mut GetHeadersByHash| { &mut m.hashes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetHeadersByHash>(
                    "GetHeadersByHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetHeadersByHash {
        static mut instance: ::protobuf::lazy::Lazy<GetHeadersByHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetHeadersByHash,
        };
        unsafe {
            instance.get(GetHeadersByHash::new)
        }
    }
}

impl ::protobuf::Clear for GetHeadersByHash {
    fn clear(&mut self) {
        self.clear_hashes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetHeadersByHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHeadersByHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetHeadersByHashReturn {
    // message fields
    pub success: bool,
    pub headers: ::protobuf::RepeatedField<super::blockHeader::BlockHeader>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetHeadersByHashReturn {
    pub fn new() -> GetHeadersByHashReturn {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }

    // repeated .BlockHeader headers = 2;

    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<super::blockHeader::BlockHeader>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<super::blockHeader::BlockHeader> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<super::blockHeader::BlockHeader> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }

    pub fn get_headers(&self) -> &[super::blockHeader::BlockHeader] {
        &self.headers
    }
}

impl ::protobuf::Message for GetHeadersByHashReturn {
    fn is_initialized(&self) -> bool {
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        for v in &self.headers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHeadersByHashReturn {
        GetHeadersByHashReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &GetHeadersByHashReturn| { &m.success },
                    |m: &mut GetHeadersByHashReturn| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::blockHeader::BlockHeader>>(
                    "headers",
                    |m: &GetHeadersByHashReturn| { &m.headers },
                    |m: &mut GetHeadersByHashReturn| { &mut m.headers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetHeadersByHashReturn>(
                    "GetHeadersByHashReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetHeadersByHashReturn {
        static mut instance: ::protobuf::lazy::Lazy<GetHeadersByHashReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetHeadersByHashReturn,
        };
        unsafe {
            instance.get(GetHeadersByHashReturn::new)
        }
    }
}

impl ::protobuf::Clear for GetHeadersByHashReturn {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_headers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetHeadersByHashReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHeadersByHashReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlocksByRange {
    // message fields
    pub fromHeight: u64,
    pub count: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlocksByRange {
    pub fn new() -> GetBlocksByRange {
        ::std::default::Default::default()
    }

    // uint64 fromHeight = 1;

    pub fn clear_fromHeight(&mut self) {
        self.fromHeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_fromHeight(&mut self, v: u64) {
        self.fromHeight = v;
    }

    pub fn get_fromHeight(&self) -> u64 {
        self.fromHeight
    }

    // uint64 count = 2;

    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }

    pub fn get_count(&self) -> u64 {
        self.count
    }
}

impl ::protobuf::Message for GetBlocksByRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fromHeight = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fromHeight != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fromHeight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.fromHeight != 0 {
            os.write_uint64(1, self.fromHeight)?;
        }
        if self.count != 0 {
            os.write_uint64(2, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksByRange {
        GetBlocksByRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fromHeight",
                    |m: &GetBlocksByRange| { &m.fromHeight },
                    |m: &mut GetBlocksByRange| { &mut m.fromHeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "count",
                    |m: &GetBlocksByRange| { &m.count },
                    |m: &mut GetBlocksByRange| { &mut m.count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlocksByRange>(
                    "GetBlocksByRange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlocksByRange {
        static mut instance: ::protobuf::lazy::Lazy<GetBlocksByRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlocksByRange,
        };
        unsafe {
            instance.get(GetBlocksByRange::new)
        }
    }
}

impl ::protobuf::Clear for GetBlocksByRange {
    fn clear(&mut self) {
        self.clear_fromHeight();
        self.clear_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlocksByRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksByRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlocksByRangeReturn {
    // message fields
    pub success: bool,
    pub blocks: ::protobuf::RepeatedField<super::block::Block>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlocksByRangeReturn {
    pub fn new() -> GetBlocksByRangeReturn {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }

    // repeated .Block blocks = 2;

    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::block::Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::block::Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::block::Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blocks(&self) -> &[super::block::Block] {
        &self.blocks
    }
}

impl ::protobuf::Message for GetBlocksByRangeReturn {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksByRangeReturn {
        GetBlocksByRangeReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &GetBlocksByRangeReturn| { &m.success },
                    |m: &mut GetBlocksByRangeReturn| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::block::Block>>(
                    "blocks",
                    |m: &GetBlocksByRangeReturn| { &m.blocks },
                    |m: &mut GetBlocksByRangeReturn| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlocksByRangeReturn>(
                    "GetBlocksByRangeReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlocksByRangeReturn {
        static mut instance: ::protobuf::lazy::Lazy<GetBlocksByRangeReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlocksByRangeReturn,
        };
        unsafe {
            instance.get(GetBlocksByRangeReturn::new)
        }
    }
}

impl ::protobuf::Clear for GetBlocksByRangeReturn {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlocksByRangeReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksByRangeReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetHeadersByRange {
    // message fields
    pub fromHeight: u64,
    pub count: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetHeadersByRange {
    pub fn new() -> GetHeadersByRange {
        ::std::default::Default::default()
    }

    // uint64 fromHeight = 1;

    pub fn clear_fromHeight(&mut self) {
        self.fromHeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_fromHeight(&mut self, v: u64) {
        self.fromHeight = v;
    }

    pub fn get_fromHeight(&self) -> u64 {
        self.fromHeight
    }

    // uint64 count = 2;

    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }

    pub fn get_count(&self) -> u64 {
        self.count
    }
}

impl ::protobuf::Message for GetHeadersByRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fromHeight = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fromHeight != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fromHeight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.fromHeight != 0 {
            os.write_uint64(1, self.fromHeight)?;
        }
        if self.count != 0 {
            os.write_uint64(2, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHeadersByRange {
        GetHeadersByRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fromHeight",
                    |m: &GetHeadersByRange| { &m.fromHeight },
                    |m: &mut GetHeadersByRange| { &mut m.fromHeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "count",
                    |m: &GetHeadersByRange| { &m.count },
                    |m: &mut GetHeadersByRange| { &mut m.count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetHeadersByRange>(
                    "GetHeadersByRange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetHeadersByRange {
        static mut instance: ::protobuf::lazy::Lazy<GetHeadersByRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetHeadersByRange,
        };
        unsafe {
            instance.get(GetHeadersByRange::new)
        }
    }
}

impl ::protobuf::Clear for GetHeadersByRange {
    fn clear(&mut self) {
        self.clear_fromHeight();
        self.clear_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetHeadersByRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHeadersByRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetHeadersByRangeReturn {
    // message fields
    pub success: bool,
    pub headers: ::protobuf::RepeatedField<super::blockHeader::BlockHeader>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetHeadersByRangeReturn {
    pub fn new() -> GetHeadersByRangeReturn {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }

    // repeated .BlockHeader headers = 2;

    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<super::blockHeader::BlockHeader>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<super::blockHeader::BlockHeader> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<super::blockHeader::BlockHeader> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }

    pub fn get_headers(&self) -> &[super::blockHeader::BlockHeader] {
        &self.headers
    }
}

impl ::protobuf::Message for GetHeadersByRangeReturn {
    fn is_initialized(&self) -> bool {
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        for v in &self.headers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHeadersByRangeReturn {
        GetHeadersByRangeReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &GetHeadersByRangeReturn| { &m.success },
                    |m: &mut GetHeadersByRangeReturn| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::blockHeader::BlockHeader>>(
                    "headers",
                    |m: &GetHeadersByRangeReturn| { &m.headers },
                    |m: &mut GetHeadersByRangeReturn| { &mut m.headers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetHeadersByRangeReturn>(
                    "GetHeadersByRangeReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetHeadersByRangeReturn {
        static mut instance: ::protobuf::lazy::Lazy<GetHeadersByRangeReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetHeadersByRangeReturn,
        };
        unsafe {
            instance.get(GetHeadersByRangeReturn::new)
        }
    }
}

impl ::protobuf::Clear for GetHeadersByRangeReturn {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_headers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetHeadersByRangeReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHeadersByRangeReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeers {
    // message fields
    pub count: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetPeers {
    pub fn new() -> GetPeers {
        ::std::default::Default::default()
    }

    // uint32 count = 2;

    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = v;
    }

    pub fn get_count(&self) -> u32 {
        self.count
    }
}

impl ::protobuf::Message for GetPeers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_uint32(2, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeers {
        GetPeers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "count",
                    |m: &GetPeers| { &m.count },
                    |m: &mut GetPeers| { &mut m.count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPeers>(
                    "GetPeers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeers {
        static mut instance: ::protobuf::lazy::Lazy<GetPeers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeers,
        };
        unsafe {
            instance.get(GetPeers::new)
        }
    }
}

impl ::protobuf::Clear for GetPeers {
    fn clear(&mut self) {
        self.clear_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeersReturn {
    // message fields
    pub success: bool,
    pub peers: ::protobuf::RepeatedField<super::peer::Peer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetPeersReturn {
    pub fn new() -> GetPeersReturn {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }

    // repeated .Peer peers = 2;

    pub fn clear_peers(&mut self) {
        self.peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: ::protobuf::RepeatedField<super::peer::Peer>) {
        self.peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peers(&mut self) -> &mut ::protobuf::RepeatedField<super::peer::Peer> {
        &mut self.peers
    }

    // Take field
    pub fn take_peers(&mut self) -> ::protobuf::RepeatedField<super::peer::Peer> {
        ::std::mem::replace(&mut self.peers, ::protobuf::RepeatedField::new())
    }

    pub fn get_peers(&self) -> &[super::peer::Peer] {
        &self.peers
    }
}

impl ::protobuf::Message for GetPeersReturn {
    fn is_initialized(&self) -> bool {
        for v in &self.peers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        for v in &self.peers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeersReturn {
        GetPeersReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &GetPeersReturn| { &m.success },
                    |m: &mut GetPeersReturn| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::peer::Peer>>(
                    "peers",
                    |m: &GetPeersReturn| { &m.peers },
                    |m: &mut GetPeersReturn| { &mut m.peers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPeersReturn>(
                    "GetPeersReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeersReturn {
        static mut instance: ::protobuf::lazy::Lazy<GetPeersReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeersReturn,
        };
        unsafe {
            instance.get(GetPeersReturn::new)
        }
    }
}

impl ::protobuf::Clear for GetPeersReturn {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_peers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeersReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeersReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTip {
    // message fields
    pub dummy: u64,
    pub header: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetTip {
    pub fn new() -> GetTip {
        ::std::default::Default::default()
    }

    // uint64 dummy = 1;

    pub fn clear_dummy(&mut self) {
        self.dummy = 0;
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: u64) {
        self.dummy = v;
    }

    pub fn get_dummy(&self) -> u64 {
        self.dummy
    }

    // bool header = 2;

    pub fn clear_header(&mut self) {
        self.header = false;
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: bool) {
        self.header = v;
    }

    pub fn get_header(&self) -> bool {
        self.header
    }
}

impl ::protobuf::Message for GetTip {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dummy = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.header = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dummy != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dummy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.header != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.dummy != 0 {
            os.write_uint64(1, self.dummy)?;
        }
        if self.header != false {
            os.write_bool(2, self.header)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTip {
        GetTip::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dummy",
                    |m: &GetTip| { &m.dummy },
                    |m: &mut GetTip| { &mut m.dummy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "header",
                    |m: &GetTip| { &m.header },
                    |m: &mut GetTip| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTip>(
                    "GetTip",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTip {
        static mut instance: ::protobuf::lazy::Lazy<GetTip> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTip,
        };
        unsafe {
            instance.get(GetTip::new)
        }
    }
}

impl ::protobuf::Clear for GetTip {
    fn clear(&mut self) {
        self.clear_dummy();
        self.clear_header();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTip {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTipReturn {
    // message fields
    pub success: bool,
    pub hash: ::std::vec::Vec<u8>,
    pub height: u64,
    pub totalwork: f64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetTipReturn {
    pub fn new() -> GetTipReturn {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }

    // bytes hash = 2;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }

    // uint64 height = 3;

    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u64) {
        self.height = v;
    }

    pub fn get_height(&self) -> u64 {
        self.height
    }

    // double totalwork = 4;

    pub fn clear_totalwork(&mut self) {
        self.totalwork = 0.;
    }

    // Param is passed by value, moved
    pub fn set_totalwork(&mut self, v: f64) {
        self.totalwork = v;
    }

    pub fn get_totalwork(&self) -> f64 {
        self.totalwork
    }
}

impl ::protobuf::Message for GetTipReturn {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.height = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.totalwork = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.totalwork != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if self.height != 0 {
            os.write_uint64(3, self.height)?;
        }
        if self.totalwork != 0. {
            os.write_double(4, self.totalwork)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTipReturn {
        GetTipReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &GetTipReturn| { &m.success },
                    |m: &mut GetTipReturn| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &GetTipReturn| { &m.hash },
                    |m: &mut GetTipReturn| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "height",
                    |m: &GetTipReturn| { &m.height },
                    |m: &mut GetTipReturn| { &mut m.height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "totalwork",
                    |m: &GetTipReturn| { &m.totalwork },
                    |m: &mut GetTipReturn| { &mut m.totalwork },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTipReturn>(
                    "GetTipReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTipReturn {
        static mut instance: ::protobuf::lazy::Lazy<GetTipReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTipReturn,
        };
        unsafe {
            instance.get(GetTipReturn::new)
        }
    }
}

impl ::protobuf::Clear for GetTipReturn {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_hash();
        self.clear_height();
        self.clear_totalwork();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTipReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTipReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutHeaders {
    // message fields
    pub headers: ::protobuf::RepeatedField<super::blockHeader::BlockHeader>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PutHeaders {
    pub fn new() -> PutHeaders {
        ::std::default::Default::default()
    }

    // repeated .BlockHeader headers = 1;

    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<super::blockHeader::BlockHeader>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<super::blockHeader::BlockHeader> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<super::blockHeader::BlockHeader> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }

    pub fn get_headers(&self) -> &[super::blockHeader::BlockHeader] {
        &self.headers
    }
}

impl ::protobuf::Message for PutHeaders {
    fn is_initialized(&self) -> bool {
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.headers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutHeaders {
        PutHeaders::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::blockHeader::BlockHeader>>(
                    "headers",
                    |m: &PutHeaders| { &m.headers },
                    |m: &mut PutHeaders| { &mut m.headers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PutHeaders>(
                    "PutHeaders",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PutHeaders {
        static mut instance: ::protobuf::lazy::Lazy<PutHeaders> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PutHeaders,
        };
        unsafe {
            instance.get(PutHeaders::new)
        }
    }
}

impl ::protobuf::Clear for PutHeaders {
    fn clear(&mut self) {
        self.clear_headers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutHeaders {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutHeaders {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutHeadersReturn {
    // message fields
    pub statusChanges: ::protobuf::RepeatedField<StatusChange>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PutHeadersReturn {
    pub fn new() -> PutHeadersReturn {
        ::std::default::Default::default()
    }

    // repeated .StatusChange statusChanges = 1;

    pub fn clear_statusChanges(&mut self) {
        self.statusChanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_statusChanges(&mut self, v: ::protobuf::RepeatedField<StatusChange>) {
        self.statusChanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statusChanges(&mut self) -> &mut ::protobuf::RepeatedField<StatusChange> {
        &mut self.statusChanges
    }

    // Take field
    pub fn take_statusChanges(&mut self) -> ::protobuf::RepeatedField<StatusChange> {
        ::std::mem::replace(&mut self.statusChanges, ::protobuf::RepeatedField::new())
    }

    pub fn get_statusChanges(&self) -> &[StatusChange] {
        &self.statusChanges
    }
}

impl ::protobuf::Message for PutHeadersReturn {
    fn is_initialized(&self) -> bool {
        for v in &self.statusChanges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statusChanges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.statusChanges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.statusChanges {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutHeadersReturn {
        PutHeadersReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusChange>>(
                    "statusChanges",
                    |m: &PutHeadersReturn| { &m.statusChanges },
                    |m: &mut PutHeadersReturn| { &mut m.statusChanges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PutHeadersReturn>(
                    "PutHeadersReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PutHeadersReturn {
        static mut instance: ::protobuf::lazy::Lazy<PutHeadersReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PutHeadersReturn,
        };
        unsafe {
            instance.get(PutHeadersReturn::new)
        }
    }
}

impl ::protobuf::Clear for PutHeadersReturn {
    fn clear(&mut self) {
        self.clear_statusChanges();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutHeadersReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutHeadersReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetHash {
    // message fields
    pub height: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetHash {
    pub fn new() -> GetHash {
        ::std::default::Default::default()
    }

    // uint64 height = 1;

    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u64) {
        self.height = v;
    }

    pub fn get_height(&self) -> u64 {
        self.height
    }
}

impl ::protobuf::Message for GetHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_uint64(1, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHash {
        GetHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "height",
                    |m: &GetHash| { &m.height },
                    |m: &mut GetHash| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetHash>(
                    "GetHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetHash {
        static mut instance: ::protobuf::lazy::Lazy<GetHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetHash,
        };
        unsafe {
            instance.get(GetHash::new)
        }
    }
}

impl ::protobuf::Clear for GetHash {
    fn clear(&mut self) {
        self.clear_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetHashReturn {
    // message fields
    pub success: bool,
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetHashReturn {
    pub fn new() -> GetHashReturn {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }

    // bytes hash = 2;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
}

impl ::protobuf::Message for GetHashReturn {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHashReturn {
        GetHashReturn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &GetHashReturn| { &m.success },
                    |m: &mut GetHashReturn| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &GetHashReturn| { &m.hash },
                    |m: &mut GetHashReturn| { &mut m.hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetHashReturn>(
                    "GetHashReturn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetHashReturn {
        static mut instance: ::protobuf::lazy::Lazy<GetHashReturn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetHashReturn,
        };
        unsafe {
            instance.get(GetHashReturn::new)
        }
    }
}

impl ::protobuf::Clear for GetHashReturn {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetHashReturn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHashReturn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusChange {
    // message fields
    pub status: i32,
    pub oldStatus: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StatusChange {
    pub fn new() -> StatusChange {
        ::std::default::Default::default()
    }

    // int32 status = 1;

    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }

    pub fn get_status(&self) -> i32 {
        self.status
    }

    // int32 oldStatus = 2;

    pub fn clear_oldStatus(&mut self) {
        self.oldStatus = 0;
    }

    // Param is passed by value, moved
    pub fn set_oldStatus(&mut self, v: i32) {
        self.oldStatus = v;
    }

    pub fn get_oldStatus(&self) -> i32 {
        self.oldStatus
    }
}

impl ::protobuf::Message for StatusChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.oldStatus = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(1, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.oldStatus != 0 {
            my_size += ::protobuf::rt::value_size(2, self.oldStatus, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status != 0 {
            os.write_int32(1, self.status)?;
        }
        if self.oldStatus != 0 {
            os.write_int32(2, self.oldStatus)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusChange {
        StatusChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "status",
                    |m: &StatusChange| { &m.status },
                    |m: &mut StatusChange| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "oldStatus",
                    |m: &StatusChange| { &m.oldStatus },
                    |m: &mut StatusChange| { &mut m.oldStatus },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatusChange>(
                    "StatusChange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusChange {
        static mut instance: ::protobuf::lazy::Lazy<StatusChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusChange,
        };
        unsafe {
            instance.get(StatusChange::new)
        }
    }
}

impl ::protobuf::Clear for StatusChange {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_oldStatus();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusChange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rnetwork.proto\x1a\x0bblock.proto\x1a\x11blockHeader.proto\x1a\x08tx.\
    proto\x1a\npeer.proto\"\x96\x0c\n\x07Network\x12!\n\x06status\x18\x01\
    \x20\x01(\x0b2\x07.StatusH\0R\x06status\x123\n\x0cstatusReturn\x18\x02\
    \x20\x01(\x0b2\r.StatusReturnH\0R\x0cstatusReturn\x12\x1b\n\x04ping\x18\
    \x03\x20\x01(\x0b2\x05.PingH\0R\x04ping\x12-\n\npingReturn\x18\x04\x20\
    \x01(\x0b2\x0b.PingReturnH\0R\npingReturn\x12\x1e\n\x05putTx\x18\x05\x20\
    \x01(\x0b2\x06.PutTxH\0R\x05putTx\x120\n\x0bputTxReturn\x18\x06\x20\x01(\
    \x0b2\x0c.PutTxReturnH\0R\x0bputTxReturn\x12!\n\x06getTxs\x18\x07\x20\
    \x01(\x0b2\x07.GetTxsH\0R\x06getTxs\x123\n\x0cgetTxsReturn\x18\x08\x20\
    \x01(\x0b2\r.GetTxsReturnH\0R\x0cgetTxsReturn\x12'\n\x08putBlock\x18\t\
    \x20\x01(\x0b2\t.PutBlockH\0R\x08putBlock\x129\n\x0eputBlockReturn\x18\n\
    \x20\x01(\x0b2\x0f.PutBlockReturnH\0R\x0eputBlockReturn\x12<\n\x0fgetBlo\
    cksByHash\x18\x0b\x20\x01(\x0b2\x10.GetBlocksByHashH\0R\x0fgetBlocksByHa\
    sh\x12N\n\x15getBlocksByHashReturn\x18\x0c\x20\x01(\x0b2\x16.GetBlocksBy\
    HashReturnH\0R\x15getBlocksByHashReturn\x12?\n\x10getHeadersByHash\x18\r\
    \x20\x01(\x0b2\x11.GetHeadersByHashH\0R\x10getHeadersByHash\x12Q\n\x16ge\
    tHeadersByHashReturn\x18\x0e\x20\x01(\x0b2\x17.GetHeadersByHashReturnH\0\
    R\x16getHeadersByHashReturn\x12?\n\x10getBlocksByRange\x18\x0f\x20\x01(\
    \x0b2\x11.GetBlocksByRangeH\0R\x10getBlocksByRange\x12Q\n\x16getBlocksBy\
    RangeReturn\x18\x10\x20\x01(\x0b2\x17.GetBlocksByRangeReturnH\0R\x16getB\
    locksByRangeReturn\x12B\n\x11getHeadersByRange\x18\x11\x20\x01(\x0b2\x12\
    .GetHeadersByRangeH\0R\x11getHeadersByRange\x12T\n\x17getHeadersByRangeR\
    eturn\x18\x12\x20\x01(\x0b2\x18.GetHeadersByRangeReturnH\0R\x17getHeader\
    sByRangeReturn\x12'\n\x08getPeers\x18\x13\x20\x01(\x0b2\t.GetPeersH\0R\
    \x08getPeers\x129\n\x0egetPeersReturn\x18\x14\x20\x01(\x0b2\x0f.GetPeers\
    ReturnH\0R\x0egetPeersReturn\x12!\n\x06getTip\x18\x15\x20\x01(\x0b2\x07.\
    GetTipH\0R\x06getTip\x123\n\x0cgetTipReturn\x18\x16\x20\x01(\x0b2\r.GetT\
    ipReturnH\0R\x0cgetTipReturn\x12-\n\nputHeaders\x18\x17\x20\x01(\x0b2\
    \x0b.PutHeadersH\0R\nputHeaders\x12?\n\x10putHeadersReturn\x18\x18\x20\
    \x01(\x0b2\x11.PutHeadersReturnH\0R\x10putHeadersReturn\x12$\n\x07getHas\
    h\x18\x19\x20\x01(\x0b2\x08.GetHashH\0R\x07getHash\x126\n\rgetHashReturn\
    \x18\x1a\x20\x01(\x0b2\x0e.GetHashReturnH\0R\rgetHashReturn\x120\n\x0bge\
    tBlockTxs\x18\x1b\x20\x01(\x0b2\x0c.GetBlockTxsH\0R\x0bgetBlockTxs\x12B\
    \n\x11getBlockTxsReturn\x18\x1c\x20\x01(\x0b2\x12.GetBlockTxsReturnH\0R\
    \x11getBlockTxsReturnB\t\n\x07request\"\x88\x01\n\x06Status\x12\x18\n\
    \x07version\x18\x01\x20\x01(\rR\x07version\x12\x1c\n\tnetworkid\x18\x02\
    \x20\x01(\tR\tnetworkid\x12\x12\n\x04port\x18\x05\x20\x01(\x05R\x04port\
    \x12\x12\n\x04guid\x18\x06\x20\x01(\tR\x04guid\x12\x1e\n\npublicPort\x18\
    \x07\x20\x01(\x05R\npublicPort\"I\n\x0cStatusReturn\x12\x18\n\x07success\
    \x18\x01\x20\x01(\x08R\x07success\x12\x1f\n\x06status\x18\x02\x20\x01(\
    \x0b2\x07.StatusR\x06status\"\x1c\n\x04Ping\x12\x14\n\x05nonce\x18\x01\
    \x20\x01(\x04R\x05nonce\"\"\n\nPingReturn\x12\x14\n\x05nonce\x18\x01\x20\
    \x01(\x04R\x05nonce\"\x1e\n\x05PutTx\x12\x15\n\x03txs\x18\x01\x20\x03(\
    \x0b2\x03.TxR\x03txs\"'\n\x0bPutTxReturn\x12\x18\n\x07success\x18\x01\
    \x20\x01(\x08R\x07success\"%\n\x0bGetBlockTxs\x12\x16\n\x06hashes\x18\
    \x01\x20\x03(\x0cR\x06hashes\"5\n\x08BlockTxs\x12\x12\n\x04hash\x18\x01\
    \x20\x01(\x0cR\x04hash\x12\x15\n\x03txs\x18\x02\x20\x03(\x0b2\x03.TxR\
    \x03txs\":\n\x11GetBlockTxsReturn\x12%\n\x08txBlocks\x18\x01\x20\x03(\
    \x0b2\t.BlockTxsR\x08txBlocks\"\x20\n\x06GetTxs\x12\x16\n\x06minFee\x18\
    \x01\x20\x01(\x04R\x06minFee\"?\n\x0cGetTxsReturn\x12\x18\n\x07success\
    \x18\x01\x20\x01(\x08R\x07success\x12\x15\n\x03txs\x18\x02\x20\x03(\x0b2\
    \x03.TxR\x03txs\"*\n\x08PutBlock\x12\x1e\n\x06blocks\x18\x01\x20\x03(\
    \x0b2\x06.BlockR\x06blocks\"E\n\x0ePutBlockReturn\x123\n\rstatusChanges\
    \x18\x01\x20\x03(\x0b2\r.StatusChangeR\rstatusChanges\"\x1e\n\x05NewTx\
    \x12\x15\n\x03txs\x18\x01\x20\x03(\x0b2\x03.TxR\x03txs\"*\n\x08NewBlock\
    \x12\x1e\n\x06blocks\x18\x01\x20\x03(\x0b2\x06.BlockR\x06blocks\")\n\x0f\
    GetBlocksByHash\x12\x16\n\x06hashes\x18\x01\x20\x03(\x0cR\x06hashes\"Q\n\
    \x15GetBlocksByHashReturn\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07\
    success\x12\x1e\n\x06blocks\x18\x02\x20\x03(\x0b2\x06.BlockR\x06blocks\"\
    *\n\x10GetHeadersByHash\x12\x16\n\x06hashes\x18\x01\x20\x03(\x0cR\x06has\
    hes\"Z\n\x16GetHeadersByHashReturn\x12\x18\n\x07success\x18\x01\x20\x01(\
    \x08R\x07success\x12&\n\x07headers\x18\x02\x20\x03(\x0b2\x0c.BlockHeader\
    R\x07headers\"H\n\x10GetBlocksByRange\x12\x1e\n\nfromHeight\x18\x01\x20\
    \x01(\x04R\nfromHeight\x12\x14\n\x05count\x18\x02\x20\x01(\x04R\x05count\
    \"R\n\x16GetBlocksByRangeReturn\x12\x18\n\x07success\x18\x01\x20\x01(\
    \x08R\x07success\x12\x1e\n\x06blocks\x18\x02\x20\x03(\x0b2\x06.BlockR\
    \x06blocks\"I\n\x11GetHeadersByRange\x12\x1e\n\nfromHeight\x18\x01\x20\
    \x01(\x04R\nfromHeight\x12\x14\n\x05count\x18\x02\x20\x01(\x04R\x05count\
    \"[\n\x17GetHeadersByRangeReturn\x12\x18\n\x07success\x18\x01\x20\x01(\
    \x08R\x07success\x12&\n\x07headers\x18\x02\x20\x03(\x0b2\x0c.BlockHeader\
    R\x07headers\"\x20\n\x08GetPeers\x12\x14\n\x05count\x18\x02\x20\x01(\rR\
    \x05count\"G\n\x0eGetPeersReturn\x12\x18\n\x07success\x18\x01\x20\x01(\
    \x08R\x07success\x12\x1b\n\x05peers\x18\x02\x20\x03(\x0b2\x05.PeerR\x05p\
    eers\"6\n\x06GetTip\x12\x14\n\x05dummy\x18\x01\x20\x01(\x04R\x05dummy\
    \x12\x16\n\x06header\x18\x02\x20\x01(\x08R\x06header\"r\n\x0cGetTipRetur\
    n\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\x12\x12\n\x04has\
    h\x18\x02\x20\x01(\x0cR\x04hash\x12\x16\n\x06height\x18\x03\x20\x01(\x04\
    R\x06height\x12\x1c\n\ttotalwork\x18\x04\x20\x01(\x01R\ttotalwork\"4\n\n\
    PutHeaders\x12&\n\x07headers\x18\x01\x20\x03(\x0b2\x0c.BlockHeaderR\x07h\
    eaders\"G\n\x10PutHeadersReturn\x123\n\rstatusChanges\x18\x01\x20\x03(\
    \x0b2\r.StatusChangeR\rstatusChanges\"!\n\x07GetHash\x12\x16\n\x06height\
    \x18\x01\x20\x01(\x04R\x06height\"=\n\rGetHashReturn\x12\x18\n\x07succes\
    s\x18\x01\x20\x01(\x08R\x07success\x12\x12\n\x04hash\x18\x02\x20\x01(\
    \x0cR\x04hash\"D\n\x0cStatusChange\x12\x16\n\x06status\x18\x01\x20\x01(\
    \x05R\x06status\x12\x1c\n\toldStatus\x18\x02\x20\x01(\x05R\toldStatusb\
    \x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
